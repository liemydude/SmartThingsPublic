/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 

def clientVersion() {
    return "3.1.4"
}

/**
* User Door Unlock/Lock Notifications and Actions. Mirror of Multi User Lock Code Mgmt without the code programming, reuse existing lock programming
*
* Copyright RBoy
* Redistribution of code is not allowed without permission
*
* Change Log:
* 2016-9-7 - Auto locks and open door notifications will engage if requried when mode changes
* 2016-9-2 - Added ability to specify modes of operations for auto door lock
* 2016-8-30 - Fixed bug with disable all push notifications, it should not disable text notifications and should only work when there is no contact address book
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-8-6 - Added support to auto relock door if the door hasn't been opened after specified timeout
* 2016-8-5 - Fix for autoRelock and openDoor notifications errors when using large timeout values
* 2016-7-25 - Added support for working with RFID cards
* 2016-7-22 - Added support for contact address book for customers who have this feature enabled
* 2016-7-19 - Updated code to use harmonized universal DH with type event instead of outsideLockEvent
* 2016-7-17 - Improvement to the unlocking and relocking logic
* 2016-7-17 - Workaround for platform calling installed and updated when installing the SmartApp
* 2016-7-17 - Put in a check to not enable automatic unlock if autolock in the door is enabled
* 2016-7-14 - Improved notifications
* 2016-7-13 - Added support for tamper events and when using user codes to lock the door from the keypad
* 2016-7-10 - Added support for running routine when the door is locked using external keypad lock button
* 2016-7-5 - Added support for notifications if door is left open, added support for delayed relock for multiple door and various minor UI improvements
* 2016-7-5 - Added client version on main page
* 2016-4-8 - Added support for notification modes for unlocking (and improved UI)
* 2016-4-8 - Bugfix for jammed and manual lock notifications not coming
* 2016-2-20 - Added slot notification for unknown users 
* 2016-2-7 - Revamped from scratch
*
*/
definition(
    name: "User Unlock/Lock Door Notifications and Actions",
    namespace: "rboy",
    author: "RBoy",
    description: "Execute actions when users unlock/lock doors",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active@2x.png"
)

import groovy.json.JsonSlurper

preferences {
	page(name: "setupApp")
    page(name: "usersPage")
    page(name: "unlockLockActionsPage")
    page(name: "relockDoorPage")
}

def setupApp() {
	log.trace "$settings"
    
    dynamicPage(name: "setupApp", title: "User Door Unlock/Lock Notifications and Actions v${clientVersion()}", install: false, uninstall: true, nextPage: "usersPage") {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock", multiple: true, submitOnChange: true
        }

		section("How many Users do you want to monitor (common to all selected locks)?") {
        	input name: "maxUserNames", title: "Max users", type: "number", required: true, multiple: false
        }

        section {
            // Unlock actions for all users (global)
            def hrefParams = [
                user: null, 
                passed: true 
            ]
            href(name: "unlockActions", params: hrefParams, title: "Click here to define actions when the user locks/unlocks the door successfully", page: "unlockLockActionsPage", description: "", required: false)
            href(name: "relockDoor", title: "Click here to automatically lock/unlock the door based on events", page: "relockDoorPage", description: "", required: false)
        }

        section() {
			label title: "Assign a name for this SmartApp (optional)", required: false
		}
    }
}

def relockDoorPage() {
    dynamicPage(name:"relockDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock and relock of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"
                def priorNotifyOpen = settings."openNotify${lock}"
                def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
                def priorOpenNotifyModes = settings."openNotifyModes${lock}"
                def priorRelockDoorModes = settings."relockDoorModes${lock}"

                paragraph "\r\n"
                paragraph "Configure ${lock}"
                if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor", required: true
                }

                input name: "relockDoor${lock}", type: "bool", title: "Relock door automatically after closing", defaultValue: priorRelockDoor, required: true, submitOnChange: true
                if (priorRelockDoor) {
                    input name: "relockImmediate${lock}", type: "bool", title: "Relock immediately", defaultValue: priorRelockImmediate, required: true, submitOnChange: true
                    if (!priorRelockImmediate) {
                        input name: "relockAfter${lock}", type: "number", title: "Relock after (minutes)", defaultValue: priorRelockAfter, required: true                   
                    }
                    input name: "relockDoorModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                }

                paragraph "Use this if you want to automatically retract the deadbolt (unlock) if it accidentally extends (locks) while the door is still open. This can avoid damage to the door frame.\nNOTE: Make sure the AutoLock feature on the lock has been disabled to use this feature otherwise it can go an infinite loop of locking/unlocking."
                input name: "retractDeadbolt${lock}", type: "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, required: true, submitOnChange: true

                paragraph "Use this if you want to be notified if the door has been left open for too long."
                input name: "openNotify${lock}", type: "bool", title: "Notify if door has been left open", defaultValue: priorNotifyOpen, required: true, submitOnChange: true
                if (priorNotifyOpen) {
                    input name: "openNotifyTimeout${lock}", type: "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"             
                    input name: "openNotifyModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
                }
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = atomicState.params?.user ?: ""
    def name = user ? settings."userNames${user}" : ""

    log.trace "Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: "Setup lock/unlock actions for each door" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()*.label
        def showActions = true
        if (phrases) {
            phrases.sort()
            section {
                if (user) { // User specific override options
                    paragraph "Enabling user specific actions will override over any general lock/unlock actions defined on the first page"
                    input "userOverrideUnlockActions${user}", "bool", title: "Define specific actions for $name", required: true,  submitOnChange: true
                    if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                        showActions = false
                    }
                }
                if  (showActions && locks?.size() > 1) {
                    input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
                }
            }
            if (showActions) { // Do we need to show actions?
                if (settings."individualDoorActions${user}") {
                    for (lock in locks) {
                        section() {
                            paragraph 	title: "$lock Lock/Unlock Actions",
                                		required: true,
                                        ""
                        }
                        
                        section ("Door Unlock Actions for $lock (optional)") {
                            def priorHomePhrase = settings."homePhrase${lock}${user}"
                            def priorHomeMode = settings."homeMode${lock}${user}"
                            def priorHomeDisarm = settings."homeDisarm${lock}${user}"
                            def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
                            def priorManualNotify = settings."manualNotify${lock}"

                            paragraph "Run these routines and/or change the mode when a user successfully unlocks the door $lock"
                            input "homePhrase${lock}${user}", "enum", title: "Run Routine", required: false, options: phrases, defaultValue: priorHomePhrase
                            input "homeMode${lock}${user}", "mode", title: "Change Mode To", required: false, multiple: false, defaultValue: priorHomeMode
                            input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false, defaultValue: priorHomeDisarm

                            paragraph "Turn on these lights after dark when a user successfully unlocks the door $lock"
                            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                            paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door $lock"
                            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true

                            if (!user) { // Users will use the user notify option
                                paragraph "Get notifications when the door is unlocked manually (inside or outside)"
                                input "manualNotify${lock}", "bool", title: "Notify on manual unlock", submitOnChange: true
                                if (priorManualNotify) {
                                    input "manualNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                                }
                            }
                        }
                        
                        section("Door Lock Actions for $lock (optional)") {
                            if (lock.hasAttribute('invalidCode')) { // For now only custom DH supports lock codes
                                paragraph "Some locks (e.g. Schlage/Yale) can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign routines to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
                                input "externalLockPhrase${lock}${user}", "enum", title: "Run routine on user lock", required: false, options: phrases, defaultValue: priorLockPhrase
                                if (!user) { // Users will use the user notify option
                                    input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", submitOnChange: true
                                    if (settings."externalLockNotify${lock}") {
                                        input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                                    }
                                }
                            } else {
                                paragraph "Use the Enhanced Z-Wave Lock device handler to get access to lock specific actions"
                            }
                            
                            if (!user) { // Users will use the user notify option
                                paragraph "Get notifications when the door is locked (manually or automatically)"
                                input "lockNotify${lock}", "bool", title: "Notify on manual lock", submitOnChange: true
                                if (settings."lockNotify${lock}") {
                                    input "lockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                                }

                                input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck"
                            }
                        }
                    }
                } else {
                    section("Door Unlock Actions (optional)") {
                        paragraph "Run these routines and/or change the mode when a user successfully unlocks the door"
                        input "homePhrase${user}", "enum", title: "Run Routine", required: false, options: phrases
                        input "homeMode${user}", "mode", title: "Change Mode To", required: false, multiple: false
                        input "homeDisarm${user}", "bool", title: "Disarm Smart Home Monitor", required: false

                        paragraph "Turn on these lights after dark when a user successfully unlocks the door"
                        input "turnOnSwitchesAfterSunset${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                        paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door"
                        input "turnOnSwitches${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                        input "turnOffSwitches${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true

                        if (!user) { // Users will use the user notify option
                            paragraph "Get notifications when the door is unlocked manually (inside or outside)"
                            input "manualNotify", "bool", title: "Notify on manual unlock", submitOnChange: true
                            if (manualNotify) {
                                input "manualNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                            }
                        }
                    }

                    section("Door Lock Actions (optional)") {
                        if (locks*.hasAttribute('invalidCode').contains(true)) { // For now only custom DH support lock codes
                            paragraph "Some locks (e.g. Schlage/Yale) can be locked from the keypad outside with a button. If your lock has his feature then you can assign routines to execute when it is locked with this button"
                            input "externalLockPhrase${user}", "enum", title: "Run routine on keypad lock", required: false, options: phrases
                            if (!user) { // Users will use the user notify option
                                input "externalLockNotify", "bool", title: "Notify on keypad lock", submitOnChange: true
                                if (externalLockNotify) {
                                    input "externalLockNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                                }
                            }
                        } else {
                            paragraph "Use the Enhanced Z-Wave Lock device handler to get access to lock specific actions"
                        }
                        
                        if (!user) { // Users will use the user notify option
                            paragraph "Get notifications when the door is locked (manually or automatically)"
                            input "lockNotify", "bool", title: "Notify on manual lock", submitOnChange: true
                            if (lockNotify) {
                                input "lockNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                            }

                            input "jamNotify", "bool", title: "Notify on Lock Jam/Stuck"
                        }
                    }
                }
            } else {
                log.warn "No Routines found!!!"
            }
        }
    }
}

def usersPage() {
	dynamicPage(name:"usersPage", title: "User Names, Actions and Notification Setup", uninstall: true, install: true) {

        section("Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app."
                input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
            }
        }

        for (int i = 1; i <= settings.maxUserNames; i++) {
            def priorName = settings."userNames${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            log.debug "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

            // Check for errors and display messages
            section("Slot #${i} User") {
                // User and code details/types
                if (priorName) {
                    input name: "userNames${i}", description: "${priorName}", title: "Name", defaultValue: priorName, type: "text", multiple: false, required: false, submitOnChange: true
                } else {
                    input name: "userNames${i}", description: "Tap to set", title: "Name", type: "text", multiple: false, required: false, submitOnChange: true
                }

                if (priorNotify) {
                    input name: "userNotify${i}", title: "Notify on unlock", defaultValue: priorNotify, type: "bool", submitOnChange: true
                    if (settings."userNotify${i}") {
                        input name: "userNotifyModes${i}", type: "mode", title: "Only when in this mode(s) (optional)", defaultValue: priorNotifyModes, required: false, multiple: true
                    }
                } else {
                    input name: "userNotify${i}", title: "Notify on unlock", type: "bool", submitOnChange: true
                    if (settings."userNotify${i}") {
                        input name: "userNotifyModes${i}", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                    }
                }

                if (priorName) {
                    // Unlock actions for each user
                    def hrefParams = [
                        user: i as String, 
                        passed: true 
                    ]
                    href(name: "unlockActions", params: hrefParams, title: "Click here to define actions for ${settings."userNames${i}"}", page: "unlockLockActionsPage", description: "", required: false)
                }
            }
        } 
    } 
}

def installed()
{
	log.debug "Install Settings: $settings"
	appTouch()
}

def updated()
{
	log.debug "Update Settings: $settings"
	appTouch()
}

def appTouch() {
	unschedule() // clear all pending updates
    unsubscribe()
    
    // subscribe to random events to kick start timers again due to buggy platform killing the timers after a while
    subscribe(location, "mode", changeHandler)

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
        	log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
        	subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }
    
    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt.name}, value: ${evt.value}"
    
    if (evt.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
            log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
            sensorHandler(sensorEvt)
        }
    }
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def data = []
    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.debug "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (settings."relockImmediate${lock}") {
                log.debug "Relocking ${lock} immediately in 3 seconds"
                def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                    log.trace "Adding ${lock.id} to the list of immediate locks"
                    immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                }
                immediateLockDoor() // Lock it right away
            } else if (settings."relockAfter${lock}") {
                log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                log.trace "Adding ${lock.id} to the list of relocks"
                reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                reLockDoor() // Call relock door it'll take of delaying the lock as required
            } else {
                log.error "Invalid configuration, no relock timeout defined"
            }
        }
    } else { // Door was opened
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (location.modes?.find{it.name == settings."openNotifyModes${lock}"})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
	log.trace "Pending immediate door locks ${unLocksIDs}"
    
    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
	log.trace "Pending immediate door locks ${immediateLocksIDs}"
    
    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                lock.lock() // lock it
                log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                startTimer(60, reLockDoor) // Check back again in some time
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user and checking again after ${settings."openNotifyTimeout${lock}"} minutes"
                def msg = "$lock has been open for ${settings."openNotifyTimeout${lock}"} minutes"
                sendNotifications(msg)

                log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

def lockHandler(evt) {
    def data = []
    def lock = evt.device

    log.debug "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"
            
            // Check if we have a sensor and delayed relock is enabled, if so then start the timer now just incase the user never opens the door
            def sensor = settings."sensor${lock}"
            if (sensor?.latestValue("contact") == "closed") { // Door is still closed
                log.trace "Found Sensor ${sensor} assigned to Lock ${lock} and it's still closed"

                if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.trace "No relock timeout defined, not scheduling relock"
                }
            }
            
            if (evt.data) { // Was it locked using a code
                data = new JsonSlurper().parseText(evt.data)
            }
            def lockMode = data?.type ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically")
            
            if (!(data?.usedCode)) { // No extended data, must be a manual/keyed unlock
                log.debug "$evt.displayName was unlocked $lockMode"

                if ((!settings."individualDoorActions" && manualNotify && (manualNotifyModes ? manualNotifyModes.find{it == location.mode} : true)) ||
                    (settings."individualDoorActions" && settings."manualNotify${lock}" && (settings."manualNotifyModes${lock}" ? settings."manualNotifyModes${lock}".find{it == location.mode} : true))) {
                    def msg = "$evt.displayName was unlocked $lockMode"
                    sendNotifications(msg)
                }
            } else {
                Integer i = data.usedCode as Integer
                def userName = settings."userNames${i}"
                def notify = settings."userNotify${i}"
                def notifyModes = settings."userNotifyModes${i}"

                log.debug "Lock $evt.displayName unlocked by $userName, notify $notify, notify modes $notifyModes, via $lockMode"

                def msg = ""

                if (userName == null) {
                    msg = "$evt.displayName was unlocked by Unknown User from slot $i via $lockMode"
                } else {
                    msg = "$evt.displayName was unlocked by $userName via $lockMode"
                }

                // Check if we have user override unlock actions defined
                def user = ""
                if (settings."userOverrideUnlockActions${i as String}") {
                    log.debug "Found per user unlock actions"
                    user = i as String
                }

                // First disarm SHM since it goes off due to other events
                if (settings."individualDoorActions${user}") {
                    if (settings."homeDisarm${lock}${user}") {
                        log.info "Disarming Smart Home Monitor"
                        sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        msg += ", disarming Smart Home Monitor"
                    }

                    if (settings."homeMode${lock}${user}") {
                        log.info "Changing mode to ${settings."homeMode${lock}${user}"}"
                        if (location.modes?.find{it.name == settings."homeMode${lock}${user}"}) {
                            setLocationMode(settings."homeMode${lock}${user}") // First do this to avoid false alerts from a slow platform
                        }  else {
                            log.warn "Tried to change to undefined mode '${settings."homeMode${lock}${user}"}'"
                        }
                        msg += ", changing mode to ${settings."homeMode${lock}${user}"}"
                    }

                    if (settings."homePhrase${lock}${user}") {
                        log.info "Running unlock Phrase ${settings."homePhrase${lock}${user}"}"
                        location.helloHome.execute(settings."homePhrase${lock}${user}") // First do this to avoid false alerts from a slow platform
                        msg += ", running routine ${settings."homePhrase${lock}${user}"}"
                    }

                    if (settings."turnOnSwitchesAfterSunset${lock}${user}") {
                        def cdt = new Date(now())
                        def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                        log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                        if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                            log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lock}${user}"} since it's after sunset but before sunrise"
                            settings."turnOnSwitchesAfterSunset${lock}${user}"?.on()
                            msg += ", turning on lights ${settings."turnOnSwitchesAfterSunset${lock}${user}"}"
                        }
                    }

                    if (settings."turnOnSwitches${lock}${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lock}${user}"}"
                        settings."turnOnSwitches${lock}${user}"?.on()
                        msg += ", turning on switches ${settings."turnOnSwitches${lock}${user}"}"
                    }

                    if (settings."turnOffSwitches${lock}${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lock}${user}"}"
                        settings."turnOffSwitches${lock}${user}"?.off()
                        msg += ", turning off switches ${settings."turnOffSwitches${lock}${user}"}"
                    }
                } else {
                    if (settings."homeDisarm${user}") {
                        log.info "Disarming Smart Home Monitor"
                        sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        msg += ", disarming Smart Home Monitor"
                    }

                    if (settings."homeMode${user}") {
                        log.info "Changing mode to ${settings."homeMode${user}"}"
                        if (location.modes?.find{it.name == settings."homeMode${user}"}) {
                            setLocationMode(settings."homeMode${user}") // First do this to avoid false alerts from a slow platform
                        }  else {
                            log.warn "Tried to change to undefined mode '${settings."homeMode${user}"}'"
                        }
                        msg += ", changing mode to ${settings."homeMode${user}"}"
                    }

                    if (settings."homePhrase${user}") {
                        log.info "Running unlock Phrase ${settings."homePhrase${user}"}"
                        location.helloHome.execute(settings."homePhrase${user}") // First do this to avoid false alerts from a slow platform
                        msg += ", running routine ${settings."homePhrase${user}"}"
                    }

                    if (settings."turnOnSwitchesAfterSunset${user}") {
                        def cdt = new Date(now())
                        def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                        log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                        if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                            log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${user}"} since it's after sunset but before sunrise"
                            settings."turnOnSwitchesAfterSunset${user}"?.on()
                            msg += ", turning on lights ${settings."turnOnSwitchesAfterSunset${user}"}"
                        }
                    }

                    if (settings."turnOnSwitches${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${user}"}"
                        settings."turnOnSwitches${user}"?.on()
                        msg += ", turning on switches ${settings."turnOnSwitches${user}"}"
                    }

                    if (settings."turnOffSwitches${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${user}"}"
                        settings."turnOffSwitches${user}"?.off()
                        msg += ", turning off switches ${settings."turnOffSwitches${user}"}"
                    }
                }

                // Check for one time codes and disable them if required
                state.usedOneTimeCodes[lock.id].add(i as String) // mark the user slot used
                codeCheck() // Check the expired code and remove from lock

                if (notify && (notifyModes ? notifyModes.find{it == location.mode} : true)) {
                    sendNotifications(msg)
                }
            }
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            log.debug "$evt.displayName was locked with description: $evt.descriptionText"

            if (evt.data) { // Was it locked using a user code
                data = new JsonSlurper().parseText(evt.data)
            }
            def lockMode = data?.type ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically")
            
            if (lockMode?.contains("keypad") || lockMode?.contains("rfid") || data?.usedCode) { // LOCKED VIA KEYPAD (keep compatibility for stock ST handler when lock codes are integrated)
                def user = ""
                def userName, notify, notifyModes, extLockNotify, extLockNotifyModes, userOverrideActions

                if (data?.usedCode) {
                    Integer i = data.usedCode as Integer
                    user = i as String
                    userName = settings."userNames${i}"
                    notify = settings."userNotify${i}"
                    notifyModes = settings."userNotifyModes${i}"
                    userOverrideActions = settings."userOverrideUnlockActions${i}"

                    // Check if we have user override lock actions defined
                    if (!settings."userOverrideUnlockActions${i}") {
                        log.trace "No user $userName specific lock action found, falling back to global actions"
                        user = "" // We don't have a user specific action defined, fall back to global actions
                    }
                } else {
                    log.trace "No usercode found in extended data for external user lock"
                }

                // Check if we have individual door actions defined (at user or global level)
                if (settings."individualDoorActions${user}") {
                    extLockNotify = settings."externalLockNotify${lock}"
                    extLockNotifyModes = settings."externalLockNotifyModes${lock}"
                } else {
                    extLockNotify = settings."externalLockNotify"
                    extLockNotifyModes = settings."externalLockNotifyModes"
                }

                log.trace "Lock $evt.displayName locked by $userName, user notify $notify, user notify modes $notifyModes, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, via $lockMode"

                def msg = "$evt.displayName was locked ${userName ? "by " + userName + " " : ""}via $lockMode" // Default message to send

                if (settings."individualDoorActions${user}") {
                    if (settings."externalLockPhrase${lock}${user}") {
                        log.info "Running $lock specific $lockMode locked Phrase ${settings."externalLockPhrase${lock}${user}"} for ${userName ?: "external lock"}"
                        location.helloHome.execute(settings."externalLockPhrase${lock}${user}") // First do this to avoid false alerts from a slow platform
                        msg = "$evt.displayName was locked ${userName ? "by " + userName + " " : ""}via $lockMode, running ${settings."externalLockPhrase${lock}${user}"}"
                    } else {
                        log.trace "No individual routine configured to run for $lock on $lockMode lock"
                    }
                } else {
                    if (settings."externalLockPhrase${user}") {
                        log.info "Running $lockMode locked Phrase ${settings."externalLockPhrase${user}"} for ${userName ?: "external lock"}"
                        location.helloHome.execute(settings."externalLockPhrase${user}") // First do this to avoid false alerts from a slow platform
                        msg = "$evt.displayName was locked ${userName ? "by " + userName + " " : ""}via $lockMode, running ${settings."externalLockPhrase${user}"}"
                    } else {
                        log.trace "No generic routine configured to run for $lock on $lockMode lock"
                    }
                }

                // Send a notification if required (message would be updated)
                if ((user && notify && (notifyModes ? notifyModes.find{it == location.mode} : true)) ||
                    (extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
                    sendNotifications(msg)
                }
            }

            // Check if we need to retract a deadbolt lock it was locked while the door was still open
            if (settings."retractDeadbolt${lock}") {
                def sensor = settings."sensor${lock}"
                if (sensor.latestValue("contact") == "open") {
                    if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                        def msg = "Unlock on door open will NOT work while the AutoLock feature is enabled on $lock lock to avoid an infinite loop to locking/unlocking"
                        log.warn msg
                        sendNotifications(msg)
                    } else {
                        log.debug "$lock was locked while the door was still open, unlocking it in 5 seconds"
                        def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                        if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                            log.trace "Adding ${lock.id} to the list of unlocks"
                            unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                            atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                        }
                        startTimer(5, unLockDoor) // Schedule the unlock in 5 seconds since the door may have just locked and avoid Z-Wave conflict
                    }
                } else {
                    log.trace "$lock was locked while the door was closed, we're good"
                }
            }

            if ((!settings."individualDoorActions" && lockNotify && (!(lockMode?.contains("keypad") || lockMode?.contains("rfid"))) && (lockNotifyModes ? lockNotifyModes.find{it == location.mode} : true)) ||
                    (settings."individualDoorActions" && settings."lockNotify${lock}" && (!(lockMode?.contains("keypad") || lockMode?.contains("rfid"))) && (settings."lockNotifyModes${lock}" ? settings."lockNotifyModes${lock}".find{it == location.mode} : true))) { // For manual and electronic locking only, keypad is handled above
                def msg = "$evt.displayName was locked $lockMode"
                sendNotifications(msg)
            }
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Too many invalid user codes detected on lock $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on lock $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}
                
def startTimer(seconds, function) {
    log.trace "Scheduled to run $function in $seconds seconds"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
}

private sendText(number, message) {
	if (sms) {
    	def phones = sms.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message) {
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (!disableAllNotify) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }
}